# Gemini 프로젝트 메모리

이 파일은 Gemini가 이 프로젝트에 대한 중요한 컨텍스트와 대화 기록을 기억하는 데 사용됩니다.

## 프로젝트 실행 컨텍스트

- **프로젝트 루트:** 현재 작업 디렉토리는 `/home/gunnerana/PycharmProjects/musicProject`입니다.
- **Python 코드 위치:** 모든 Python 스크립트는 `backend` 하위 디렉토리에 있습니다.
- **실행 규칙:** 모든 Python 스크립트는 `backend` 디렉토리 내에서 실행되어야 합니다. 예: `backend` 디렉토리에서 `python3 test.py` 실행.

## 대화 요약 (2025-08-30 - 현재 세션)

- **목표:** `test.py`의 오디오 동기화 알고리즘 정확도 문제 해결. 초기 `-16.04초`라는 결과값에 약 1초의 오차가 있다는 사용자 피드백에서 시작.

- **주요 논의 및 발견:**
    - **'가짜 피크' 문제 식별**: 저해상도 상관관계 그래프 시각화를 통해, 음악의 반복적인 패턴으로 인해 여러 개의 '가짜 피크'가 발생하며, 알고리즘이 가장 높은 피크를 잘못 선택하고 있음을 확인.
    - **다중 후보 검증 방식 도입**: 가장 높은 피크 하나만 보는 대신, 'prominence' 기준으로 유의미한 모든 후보 피크를 찾고, 각 후보를 고해상도 오디오 조각으로 정밀 검증하여 최고점자를 선택하는 방식으로 알고리즘을 개선.
    - **'정밀 점수'의 함정 발견**: 다중 후보 검증 결과, `-139초`라는 비현실적인 후보가 가장 높은 '정밀 점수'를 획득하는 문제 발생. 이는 음악적으로 복잡한 구간보다, 조용하거나 단순한 구간이 수학적으로 더 완벽하게 일치하여 점수가 더 높게 나오는 '파란 하늘 문제' 때문임을 분석.
    - **'침묵 후보 제거' 시도**: '파란 하늘 문제'가 침묵 구간의 일치 때문일 것이라는 가설 하에, RMS 에너지를 측정하여 침묵 구간 후보를 제거하는 로직을 추가. 하지만 모든 후보가 충분한 에너지를 가지고 있어, 이 방법으로는 '가짜 정답'을 걸러낼 수 없음을 확인.
    - **'줌인(Zoom-in)' 알고리즘 개발**: 최종적으로, 가장 안정적인 2단계 접근법을 개발.
        1. 저해상도로 전체를 탐색해 가장 높은 피크(`-16.04초`)를 '앵커'로 찾는다.
        2. '앵커' 주변의 좁은 범위만 고해상도 오디오로 다시 정밀 탐색하여 오차를 보정한다.
    - **`np.roll` 버그 수정**: 최종 오디오 생성 시, `np.roll` 함수가 오디오 순서를 섞는 문제를 발견. 이를 '패딩 및 잘라내기' 방식으로 수정하여 해결.

- **현재 상태:**
    - '줌인' 알고리즘을 통해 최종적으로 `-14.04초`라는 결과를 얻었음.
    - 하지만 사용자는 이 결과 역시 만족스럽지 않다고 피드백.
    - 현재 알고리즘의 논리적 한계에 도달했으며, 문제 해결을 위해 사용자로부터 더 정확한 '정답' 정보(기대 시간차 값 등)를 받아 분석을 진행하기로 함.

## 대화 요약 (2025-08-28 - 이전 세션)

- **목표:** `test.py`의 오디오 동기화 정확도 문제 해결 및 알고리즘 개선.

- **주요 논의 및 발견:**
    - **오디오 랙(Lag) 문제:** 사용자가 `test.py`의 계산된 랙이 실제와 다르다고 보고.
    - **GCC-PHAT 정확도 논의:** GCC-PHAT 단독으로는 샘플 이하(sub-sample) 정밀도를 얻기 어렵다는 사용자 지적. 이에 **GCC-PHAT + 서브샘플 보간법** 조합이 가장 정확한 방법임을 확인.
    - **청크 기반 탐색 도입:** 긴 오디오 파일의 랙 계산 효율성 및 정확도 향상을 위해 '청크 기반 탐색' 방식 제안.
        - 초기 '앞부분 1분' 청크 사용 시 랙이 오히려 증가하는 문제 발생.
        - 원인: 청크의 특징 부족으로 인한 '가짜 피크(false positive)' 매칭.
    - **`test.py` 코드 검토:** 코드 자체의 버그는 발견되지 않았으며, 문제는 데이터의 특성(청크의 특징 부족) 때문으로 판단.
    - **`test2.py` 및 `test3.py` 비교:**
        - `test2.py`는 현재 '음원 분리' 스크립트임을 확인. 동기화 관련 코드는 없음.
        - `test3.py`는 `test.py`보다 훨씬 정교한 '다단계 오디오 동기화' 스크립트임을 확인. (저해상도 탐색 -> 최적 윈도우 선택 -> 정밀 보정)
        - `test3.py`의 결과가 `test.py`보다 좋았으나, 여전히 정밀도가 부족하다는 사용자 피드백.
    - **`test.py` 알고리즘 최종 개선:** `test3.py`의 다단계 로직을 `test.py`에 이식하고, `test3.py`의 최종 단계(NCC) 대신 노이즈에 더 강한 **GCC-PHAT을 사용하여 정밀도를 높이는 개선 사항을 적용**함.

- **스크립트 수정 (`test.py`):**
    - `test.py`의 동기화 알고리즘을 `test3.py`의 다단계 방식(저해상도 탐색, 최적 윈도우 선택)으로 전면 교체.
    - 최종 정밀 보정 단계에서 NCC 대신 GCC-PHAT + 서브샘플 보간법을 사용하도록 개선.
    - `find_lag_gcc_phat` 및 `apply_fractional_shift` 함수 유지 및 통합.

## 대화 요약 (2025-08-20 - 이전 세션)

- **목표:** `test.py`의 사소한 동기화 오류(~0.17 샘플) 해결 및 스크립트 기능 발전.

- **주요 논의 및 발견:**
    - **MP3 vs WAV:** MP3를 WAV로 변환할 때 인코더 패딩으로 인해 실제 물리적 지연이 발생할 수 있으며, 스크립트가 이를 정확히 감지함을 논의.
    - **알고리즘 분석:** 동기화 스크립트의 2단계(거친 + 미세) 정렬 과정이 필수적임을 심층 분석. 거친(크로마) 단계는 원하는 실제 값에서 상당한 오프셋(~4250 샘플)을 가지며, 미세 조정 단계가 높은 정밀도를 달성하여 미미한 잔여 오차만 남김.

- **스크립트 수정 (`test.py` & `test2.py`):
    1.  **실제 값 측정:** `[비챤].wav`와 `[비챤]_perfect_aligned.wav` 간의 지연이 `707838.964985` 샘플임을 측정.
    2.  **실제 값 업데이트:** `test.py`와 `test2.py`의 `DESIRED_TRUE_SHIFT_SAMPLES` 상수를 새로 측정된 값으로 변경.
    3.  **3개 파일 정렬 로직 생성:** `test2.py`를 세 파일(`x`, `y`, `z`)을 받도록 수정. 스크립트는 이제 `x`와 `y` 간의 랙을 계산한 다음, 동일한 랙을 `z`에 적용.
    4.  **버그 수정:** 사용자 피드백에 따라 `test2.py`의 최종 적용된 랙의 부호 수정.
    5.  **오류 표시 추가:** `test2.py`에 새로운 실제 값에 대한 계산된 오류를 표시하는 출력 추가.

## 대화 요약 (2025-08-10)

- 사용자가 기록을 저장할 파일 생성을 요청.
- 사용자가 전역 `GEMINI.md` 파일의 위치에 대해 질문.
- 사용자가 향후 세션을 위한 대화 기록을 기록할 프로젝트별 `GEMINI.md` 생성을 요청.

## 대화 요약 (2025-08-10 - 이전 세션)

- **목표:** `test.py`의 오디오 동기화 정확도 향상.
- **초기 상태:** 스크립트는 동기화를 위해 GCC-PHAT을 사용.
- **반복 및 개선:**
  1.  **경로 설정:** 절대 경로에서 상대 경로로 전환.
  2.  **필터링:** 오디오에서 사람 목소리 주파수를 제거하기 위해 `scipy`를 사용한 밴드 스톱 필터 추가 (대상은 노래였으므로).
  3.  **알고리즘 발전:**
      - 단순 GCC-PHAT에서 더 강력한 하이브리드 모델로 발전.
      - **하이브리드 모델:** 빠르고 거친 탐색을 위해 GCC-PHAT을 사용한 다음, 정확하고 샘플 단위의 시작 시간 정제를 위해 DTW(동적 시간 왜곡) 사용.
  4.  **코드 참조:** MFCC 정규화 및 올바른 데이터 전치를 포함하는 더 정확한 DTW 계산 방법을 채택하기 위해 `FindStartTime.py` 참조.
  5.  **병렬 처리:** 가장 계산 비용이 많이 드는 DTW 정제 단계를 가속화하기 위해 `ray` 통합.
  6.  **시각화:** 오디오 파형과 감지된 시작 시간을 시각화하기 위해 `matplotlib` 플로팅(`plt.show()`) 추가.
- **최종 과제:** `pytubefix`를 사용하여 YouTube에서 새 오디오 파일을 다운로드하려 했으나, `ModuleNotFoundError` 발생.
- **근본 원인 진단:** 필요한 종속성이 포함된 사용자 Python 가상 환경 내에서 도구가 실행되지 않는다는 것을 발견.
- **다음 단계:** 사용자가 올바른 가상 환경을 활성화하고 세션을 다시 시작할 예정.

## 대화 요약 (2025-08-10 - 현재 세션)

- **초기 문제:** 사용자가 `test.py` 정확도 문제 보고, 이후 `ModuleNotFoundError` for `pytubefix`.
- **YouTube 다운로드:** `download_and_convert.py`를 YouTube 다운로드용으로 확인하고 성공적으로 실행.

- **`test.py` 클래스 리팩토링 (`AudioSynchronizer`):**
    - 사용자가 `test.py`를 원본 파일을 받는 `__init__`과 반응 파일에 대한 메서드를 가진 클래스로 리팩토링 요청.
    - `__init__(original_audio_path)`와 `synchronize(reaction_audio_path)`를 가진 `AudioSynchronizer` 클래스 구현.
    - `librosa`에서 `soundfile`로 오디오 로딩 마이그레이션 및 모든 로드된 오디오가 모노인지 확인.
    - 가독성 향상을 위해 내부 헬퍼 메서드 이름 변경 (예: `_load_audio_mono`를 `_load_mono`로, `_chroma_feat`를 `_chroma`로).
    - 사용자가 `AudioSynchronizer` 클래스 내용을 `test.py`에서 `test2.py`로 이동.

- **정확도 발견 및 오류 해결:**
    - `test.py` (현재 `test2.py`의 `AudioSynchronizer`)는 동기화 결과에 지속적으로 편향을 보였지만(예: 수백에서 수십만 샘플의 오류), `test2.py` (고급 방법)는 완벽하게 정렬된 기준 파일에 대해 0 오류를 달성.
    - `_slide_sim`을 수정하여 `inf` 오류 해결. 오디오 길이에 따라 하이 스택(더 긴 오디오)과 니들(더 짧은 오디오)을 동적으로 할당하여 `needle frame count > haystack` 조건 방지.
